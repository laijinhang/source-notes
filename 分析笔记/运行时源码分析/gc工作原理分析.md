# 一、理论
说明：这边大部分是通过学习[Golang GC](https://www.bilibili.com/video/BV1wz4y1y7Kd?from=search&seid=16207934456737462819)，做的笔记，不得不说，这个视频讲的真心不错，逻辑很清晰

### 1. 历史
### 2. make and sweep
**流程：**
1. 启动STW：暂停程序业务逻辑，找出不可达的对象和可达对象
2. Mark标记：开始标记，找出所有可达对象，并做上标记
3. Sweep清除：标记完后，然后开始清除未标记的对象
4. 停止STW：停止暂停，继续恢复程序业务，然后循环重复这个过程，直到process程序生命周期

STW暂停范围：1~4步骤

**优化：**
* 将步骤3和步骤4交换，让清除工作与程序业务并行，缩短STW的范围，缩短暂停时间

**缺点：**
1. STW，stop the world，让程序暂停，程序出现卡顿现象
2. 标记需要扫描整个heap
3. 清除数据会产生head碎片

### 3. 三色标记
* 白色
* 灰色：临时状态，三色标记结束后，灰色的对象个数是0
* 黑色

1. 一开始所有的都标成白色，从root集合出发，将可达的设为灰色，放入灰色队列
2. 从灰色队列最前面取出一个，然后将其标为黑色，它后面的第一个可达标为灰色，然后将其放入到灰色队列
3. 重复步骤2，直到灰色队列为空
4. 将剩下的所有白色对象清除

使用BFS（广度遍历算法）

三色标记存在一个问题，就是在处理过程中，因为没有STW，可能有 白色对象被黑色对象引用，导致不该被清除的被清除，或者出现 原本需要被清除没有被清除，白色对象没有被引用了

为了解决这个问题，因此有了写屏障技术

写屏障又分为：
* 强三色不变式：不允许黑色对象引用白色对象
* 弱三色不变式：允许黑色对象引用白色对象，但是需要满足以一种
    白色对象被灰色对象直接引用
    白色对象被灰色对象间接引用，也就是这个白色对象一直往上（上游）会存在一个灰色对象
* 混合写屏障

从弱三色不变式中，可以理解为什么是使用BFS，而不是DFS

**屏障：**
* 在程序正常运行中加一个“额外的判断机制”，其思想类似Hook、回调、handler，通过屏障来抑制 上面所说三色标记中存在的那个问题

**屏障机制：**
* 插入屏障：对象被引用时，触发的机制
    具体操作：在A对象引用B对象的时候，B对象被标记为灰色。（将B挂在A下游，B必须被标记为灰色）
    满足：强三色不变式，（不存在黑色对象引用白色对象的情况了，因为白色会强制变成灰色）
    伪代码：说明出于性能，不在栈上使用。对于栈的话，是使用STW暂时保护
        添加下游对象(当前下游对象slot, 新下游对象ptr) {
            // 1 
            标记灰色(新下游对象ptr)
            
            // 2
            当前下游对象slot = 新下游对象ptr
        }
    不足：结束时，需要STW来重新扫描栈，大约10~100ms
* 删除屏障：对象被删除时，触发的机制
    具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色
    满足：弱三色不变式。（保护灰色对象到白色对象的路径不会断）
    伪代码：
        添加下游对象(当前下游对象slot, 新下游对象ptr) {
            // 1 
            if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
                标记灰色（当前下游对象slot）    // slot为被删除对象，标记为灰色
            }
            
            // 2
            当前下游对象slot = 新下游对象ptr
        }
    不足：
        回收精度低：一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清除掉
# 二、GC初始化
runtime/proc.go
```go
func schedinit() {
	...
	// 垃圾回收器初始化
	gcinit()
	...
}
```
# 三、启动GC后台工作
runtime/proc.go
```go
func main() {
	...
    gcenable()
	...
}
```
runtime/mgc.go
```go
func gcenable() {
	// Kick off sweeping and scavenging.
	// 开启清扫的程序
	gcenable_setup = make(chan int, 2)
	go bgsweep()
	go bgscavenge()
	<-gcenable_setup
	<-gcenable_setup
	gcenable_setup = nil
	memstats.enablegc = true // now that runtime is initialized, GC is okay
}
```
