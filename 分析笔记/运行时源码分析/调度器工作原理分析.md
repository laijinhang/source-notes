调度器，所有 Goroutine 被调度的核心，存放了调度器持有的全局资源，访问这些资源需要持有锁：
* 管理了能够将G和M进行绑定的M队列
* 管理了空闲的P链表（队列）
* 管理了G的全局队列
* 管理了可被复用的G的全局缓存
* 管理了defer池
# 一、结构
### 1. 数据结构
```go
/*
调度器sched结构
*/
type schedt struct {
	// accessed atomically. keep at top to ensure alignment on 32-bit systems.
	goidgen   uint64
	lastpoll  uint64 // time of last network poll, 0 if currently polling
	pollUntil uint64 // time to which current poll is sleeping

	lock mutex

	// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
	// sure to call checkdead().

	// 空闲的 M 列表
	midle muintptr // idle m's waiting for work
	// 空闲的 M 列表数量
	nmidle       int32 // number of idle m's waiting for work
	nmidlelocked int32 // number of locked m's waiting for work
	// 下一个被创建的 M 的 id
	mnext     int64 // number of m's that have been created and next M ID
	maxmcount int32 // maximum number of m's allowed (or die)
	nmsys     int32 // number of system m's not counted for deadlock
	nmfreed   int64 // cumulative number of freed m's

	ngsys uint32 // number of system goroutines; updated atomically

	pidle  puintptr // idle p's	// 空闲p链表
	npidle uint32   // 空闲p数量
	// 自旋状态的M的数量
	nmspinning uint32 // See "Worker thread parking/unparking" comment in proc.go.

	// Global runnable queue.
	// 全局 runnable G 队列
	runq     gQueue
	runqsize int32

	// disable controls selective disabling of the scheduler.
	//
	// Use schedEnableUser to control this.
	//
	// disable is protected by sched.lock.
	disable struct {
		// user disables scheduling of user goroutines.
		user     bool
		runnable gQueue // pending runnable Gs
		n        int32  // length of runnable
	}

	// Global cache of dead G's.
	// 有效 dead G 的全局缓存。
	gFree struct {
		lock    mutex
		stack   gList // Gs with stacks		// 包含栈的Gs
		noStack gList // Gs without stacks	// 没有栈的Gs
		n       int32
	}

	// Central cache of sudog structs.
	// sudog 结构中的集中缓存
	sudoglock  mutex
	sudogcache *sudog

	// Central pool of available defer structs of different sizes.
	// 不同大小的有效 defer 结构的池
	deferlock mutex
	deferpool [5]*_defer

	// freem is the list of m's waiting to be freed when their
	// m.exited is set. Linked through m.freelink.
	freem *m

	gcwaiting  uint32 // gc is waiting to run
	stopwait   int32
	stopnote   note
	sysmonwait uint32
	sysmonnote note

	// While true, sysmon not ready for mFixup calls.
	// Accessed atomically.
	sysmonStarting uint32

	// safepointFn should be called on each P at the next GC
	// safepoint if p.runSafePointFn is set.
	safePointFn   func(*p)
	safePointWait int32
	safePointNote note

	profilehz int32 // cpu profiling rate

	procresizetime int64 // nanotime() of last change to gomaxprocs
	totaltime      int64 // ∫gomaxprocs dt up to procresizetime

	// sysmonlock protects sysmon's actions on the runtime.
	//
	// Acquire and hold this mutex to block sysmon from interacting
	// with the rest of the runtime.
	sysmonlock mutex

	_ uint32 // ensure timeToRun has 8-byte alignment

	// timeToRun is a distribution of scheduling latencies, defined
	// as the sum of time a G spends in the _Grunnable state before
	// it transitions to _Grunning.
	//
	// timeToRun is protected by sched.lock.
	timeToRun timeHistogram
}
```
### 2. 状态
# 二、工作原理
### 1. 协程切换
runtime/proc.go

gopack用于协程的切换，协程切换的原因一般有以下几种情况：
1. 系统调用
2. channel读写条件不满足
3. 抢占式调度时间片结束
   gopack函数做的主要事情分为两点：
1. 解除当前goroutine与m的绑定关闭，将当前goroutine状态机切换为等待状态；
2. 调用一次schedule()函数，在局部调度器P发起一轮新的调度。
```go
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
	if reason != waitReasonSleep {
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
	}
	mp := acquirem()
	gp := mp.curg
	status := readgstatus(gp)

	if status != _Grunning && status != _Gscanrunning {
		throw("gopark: bad g status")
	}
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waittraceev = traceEv
	mp.waittraceskip = traceskip
	releasem(mp)
	// can't do anything that might move the G between Ms here.
	/*
		协程切换工作：
		1. 切换当前线程的堆栈从g的堆栈切换到g0的堆栈；
		2. 并在g0的堆栈上执行新的函数fn(g)；
		3. 保存当前协程的信息（PC/SP存储到g->sched)，当后续对当前协程调用Goready函数时候能够恢复现场；
		mcall函数是通过汇编实现的，64位机的实现代码在 asm_amd64.s
		它将当前正在执行的协程状态保存起来，然后在m->g0的堆栈上调用新的函数。在新的函数内会将之前运行的协程放弃，
		然后调用一次schedule()来挑选新的协程运行（也就是在传入的函数中调用一次schedule()函数进行一次schedule的重新调度，
		让m去运行其余的goroutine）。
	*/
	mcall(park_m)
}
```