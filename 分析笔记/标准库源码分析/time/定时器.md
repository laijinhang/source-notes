# 一、时间堆
### 1、数据结构
```go
// runtime/runtime2.go
type p struct {
    timersLock mutex
    timers []*timer
    timer0When uint64
    numTimers uint32
}
```
* P.timersLock：定时器锁，保护P.times字段
* P.timers：时间堆，存放了绑定在P上的定时器列表，必须持有timersLock才能访问
* P.timer0When：最先触发的定时器的when绑定在P上的timer0When字段上，如果这个字段的值是0，表示这个定时器堆是空的，这个字段是用原子操作进行修改的
* P.numTimers：P的堆中定时器数量，这个字段是通过原子操作进行修改的

### 2、定时器
```go
// time/tick.go
type Ticker struct {
	// 用于传输时间的通道
	C <-chan Time // The channel on which the ticks are delivered.
	r runtimeTimer
}

// /runtime/time.go
type runtimeTimer struct {
    /*
        该定时器所绑定的p
    */
    pp       uintptr
    /*
        定时器触发时间
    */
    when     int64
    period   int64
    /*
        定时器触发的时候，要执行的函数
    */
    f        func(interface{}, uintptr) // NOTE: must not be closure	// 注意：不得关闭
    /*
        传入f中的第一个参数，分析源码，一般是chan Time
    */
    arg      interface{}
    seq      uintptr
    nextwhen int64
    status   uint32
}
```



# 二、原理分析
### 1、创建定时器
我们可以使用time.NewTicker方法来创建一个定时器，其中time.Tick内部是封装了Time.NewTicker，创建一个定时器有以下几个步骤：
1. 如果传入的毫秒数小于等于0，则会panic
2. 创建一个长度为1的有缓冲通道（ps：提供给用户用的是读，一开始是空内容，用户读的时候，被阻塞，时间到了的话，往这个chan写内容，之后会触发）
3. 创建一个Ticker定时器对象，并进行初始化设值
4. 之后把这个定时器绑定到当前p的时间堆上
5. 绑定完之后，返回到用户调用函数的地方
### 2、触发开启前
### 3、触发进行中
### 4、触发结束
### 5、再次触发
### 6、销毁定时器