# 一、数据结构
### 1. 互斥锁
```go
type Mutex struct {
	// state是一个共用的字段
	// 从左到右的 第 0个bit位 标记 mutex 是否被某个协程占用，也就是有没有加锁
	// 从左到右的 第 1个bit位 标记 mutex 是否被唤醒，就是某个被唤醒的mutex尝试去获取锁
	// 从左到右的 第 2个bit位 标记 mutex 是否饥饿状态
	// 剩下的bit位表示 waiter 的个数，最大允许记录 1<<(32-3) 个协程
	// [阻塞的goroutine个数, starving标识, woken标识, locked标识]
	state int32
	sema  uint32
}
```
### 2. 互斥锁状态
互斥锁一共有4种状态：
* 未被占用
* 锁定状态

# 二、工作原理
互斥锁分为正常模式和饥饿模式这两种模式

正常模式拥有更多的性能，因为即使有等待抢锁的waiter，协程也可以连续多次获取到锁。
饥饿模式是锁公平性和性能的一种平衡，它避免了某些协程长时间的锁等待。
在饥饿模式下，优先处理的是那些在一直等待的waiter。饥饿模式在一定时会切换回正常模式。
### 1. 正常模式
在正常模式下，等待的waiter会进入一个FIFO队列，在获取时waiter会按照FIFO的顺序获取，
唤醒一个waiter时，它不会立即获取锁，而是继续与新来的协程竞争，这种情况下，信赖的协程
比较有优势，主要时因为它已经运行在CPU，可能这种的数量还不少，所以waiter获取不到锁的
概率也比较大。在这种waiter获取不到锁的情况，waiter会被添加到队列的前面。如果waiter
获取不到锁的时间超过1毫秒，

这里的waiter是指新来的协程尝试获取获取锁，如果获取不到我们就将其看成waiter，并将其添加到FIFO队列里。
### 2. 饥饿模式
在饥饿模式下，锁将直接交给队列最前面的waiter，新来的协程即使在锁未被其他协程拥有下也不会参与竞争，
同时也不会进行自旋，而直接将其添加到队列的尾部。

### 3. 饥饿模式 切回 正常模式
如果拥有锁的waiter发现有以下两种情况，它将切回到正常模式：
1. 它是队列里的waiter，再没有其他waiter
2. 等待时间小于1毫秒
### 4. 自旋
1. runtime_canSpin 对应 runtime/proc.go `func sync_runtime_canSpin(i int) bool`

想要实现自旋，必须符合以下条件：
1. 自旋次数小于4，（runtime里常量active_spin里设置了固定值4）
2. CPU必须时多核处理器
3. 当前程序设置的gomaxprocs个数 > 空闲p个数+当前处于自旋m的个数+1
4. 至少有一个正在运行的P的本地运行队列为空
# 三、实现原理
### 1. Lock
1. 尝试获取锁，通过原子操作的方式 从未锁到上锁，如果成功，则获取锁成功，否则继续执行后面的
2. 这个协程先做以下初始化操作：
    当前协程不是饥饿状态
    当前协程不是唤醒状态
    当前协程自旋次数为零
    获取当前锁的状态
   
3. 如果当前锁的状态是锁定或饥饿，则判断能否进行自旋，如果可以进行自旋，
    先进行判断，
        当前协程不是唤醒状态
        锁的状态不是唤醒状态
        当前等待唤醒的锁不为0
        并且通过原子操作尝试唤醒，如果唤醒的话，则设置协程唤醒成功
    自旋
    当前协程的自旋次数加以
    获取当前锁最新状态
    之后继续执行步骤3
4. 如果锁处于正常模式，则尝试加锁
5. 如果当前是处于饥饿模式，则更新waiter数量+1
6. 当前协程处于饥饿状态，且锁被其它协程持有，新状态则更新锁为饥饿模式
7. 如果当前协程的waiter被唤醒，则重置flag
### 2. Unlock
